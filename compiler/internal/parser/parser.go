package parser

import (
	"myLang/compiler/internal/ast"
	"myLang/compiler/internal/laxer"
	"myLang/compiler/internal/tokens"
)

// Parser represents a parser that parses the tokens generated by the lexer.
type Parser struct {
	l         *laxer.Lexer // The lexer instance
	curToken  tokens.Token // The current token being examined
	peekToken tokens.Token // The next token (used for lookahead)
}

// NewParser creates a new Parser instance with the given lexer.
// It initializes the parser by reading the first two tokens.
func NewParser(l *laxer.Lexer) *Parser {
	p := &Parser{l: l}
	// Read two tokens so current and peek are set
	p.nextToken()
	p.nextToken()
	return p
}

// nextToken advances the parser to the next token.
// It updates curToken to peekToken and peekToken to the next token from the lexer.
func (p *Parser) nextToken() {
	p.curToken = p.peekToken
	p.peekToken = p.l.NextToken()
}

// ParseProgram parses the entire program and returns the root AST node.
func (p *Parser) ParseProgram() *ast.Program {
	program := &ast.Program{}
	program.Statements = []ast.Statement{}

	for p.curToken.Type != tokens.TOKEN_EOF {
		stmt := p.parseStatement()
		if stmt != nil {
			program.Statements = append(program.Statements, stmt)
		}
		p.nextToken()
	}
	return program
}

// parseStatement parses a single statement based on the current token type.
func (p *Parser) parseStatement() ast.Statement {
	if p.curToken.Type == tokens.TOKEN_CHAI_SAY {
		return p.parseChaiSayStatement()
	}
	return nil
}

// parseChaiSayStatement parses a chai_say statement.
// It expects the current token to be 'chai_say' and the next token to be a string.
func (p *Parser) parseChaiSayStatement() *ast.ChaiSayStatement {
	stmt := &ast.ChaiSayStatement{Token: p.curToken}

	if p.peekToken.Type != tokens.TOKEN_STRING {
		return nil // Simple error suppression
	}

	p.nextToken() // Move to the string
	stmt.Value = p.curToken.Literal
	return stmt
}
